# Telegram Gifts Auction

Конкурсная работа по Backend-разработке. Реализация механики аукционов Telegram Gift с обработкой конкурентных запросов и финансовой целостностью.

## Для судей (TL;DR)

Проект демонстрирует backend-реализацию аукциона с:

- **Атомарностью ставок**: блокировка средств и запись/обновление ставки выполняются в **одной MongoDB транзакции** (Replica Set).
- **Финансовой целостностью**: баланс/lockedBalance/списания ведутся через `PaymentService` и журнал `Transactions`.
- **Раундами и честным распределением**: `AuctionEngine` завершает раунды, определяет победителей по текущему раунду и переводит ставки проигравших в следующий раунд без повторной ставки.
- **Anti-sniping**: ставка в последние **15 секунд** продлевает раунд на **30 секунд**.
- **Защитой от гонок**: лок на пользователя в HTTP-роутах + optimistic concurrency Mongoose.

Упрощение для демо: авторизация реализована через заголовок `x-user-id` (вместо JWT/Telegram auth).

---

## Демо

Видео: [[КЛИК](https://youtu.be/g5u8a2vmCfg)]

Сайт: [[КЛИК](https://tggiftsauction-production.up.railway.app)]

---

## Оглавление

1. [Механика аукционов](#механика-аукционов)
2. [Архитектура](#архитектура)
3. [Выбор технологий](#выбор-технологий)
4. [Ключевые инженерные решения](#ключевые-инженерные-решения)
5. [Запуск](#запуск)
6. [Инфраструктура и деплой](#инфраструктура-и-деплой)
7. [API](#api)
8. [Тестирование](#тестирование)

---

## Механика аукционов

### Многораундовая структура

Аукцион состоит из N раундов. В каждом раунде фиксированное количество победителей (например, 10). Побеждают участники с наибольшими ставками. Проигравшие автоматически переносятся в следующий раунд - повторная ставка не требуется.

> **Пояснение для доходяг**: Количество раздаваемых подарков не указывается явно, потому что, достаточно задать число раундов и победителей в каждом. Например, для раздачи 10 000 подарков можно создать 100 раундов по 100 победителей.

```txt
Аукцион: "Premium Gift Box" - 10 штук, 3 раунда

Раунд 1: топ-10 по ставкам получают подарки
Раунд 2: топ-10 из оставшихся получают подарки
Раунд 3: топ-10 из оставшихся получают подарки
```

### Блокировка средств

При ставке средства переходят из свободного баланса в заблокированный. При повышении ставки блокируется только разница.

```txt
Баланс: 1000, Заблокировано: 0

Ставка 100 -> Баланс: 900, Заблокировано: 100
Повышение до 150 -> Баланс: 850, Заблокировано: 150 (заблокировано +50, не +150)

Победа -> Баланс: 850, Заблокировано: 0, Инвентарь: +1 подарок
```

### Anti-Sniping

Ставка в последние 15 секунд раунда продлевает таймер на 30 секунд. Это предотвращает тактику "снайпинга" - перебивания ставок в последний момент.

### Перенос ставок

Ставки проигравших участников остаются активными в следующем раунде. Средства остаются заблокированными до победы или завершения аукциона.

### Передача подарков

Выигранные подарки можно передать другому пользователю. В инвентаре нажмите на подарок и введите username получателя.

### Защита и безопасность

- **Rate Limiting**: Создание аукционов - 1 раз в 5 секунд, депозит/вывод - 1 раз в 3 секунды
- **User Locks**: Защита от race conditions при одновременных действиях одного пользователя
- **Input Validation**: Санитизация всех входных данных, защита от XSS и NoSQL-инъекций
- **Username**: Только a-zA-Zа-яА-ЯёЁ0-9_-, 3-30 символов
- **Лимиты**: Bid 1-10,000,000, Deposit -100,000 до +100,000

---

## Архитектура

```txt
Frontend (React + Vite)
    |
    | HTTP REST API, polling (оптимизирован по активному экрану)
    v
Backend (Node.js + Fastify)
    |
    +-- AuthService      - авторизация
    +-- BidService       - ставки, anti-sniping, валидация
    +-- PaymentService   - балансы, транзакции
    +-- AuctionEngine    - фоновый процесс завершения раундов
    |
    v
MongoDB (Replica Set)
    +-- Users        - баланс, lockedBalance
    +-- Auctions     - раунды, статус, items
    +-- Bids         - ставки с версионированием
    +-- Transactions - журнал операций
```

### Backend

```txt
backend/src/
├── models/
│   ├── User.ts          - пользователь, баланс
│   ├── Auction.ts       - аукцион, раунды
│   ├── Bid.ts           - ставка
│   └── Transaction.ts   - запись в журнале
├── services/
│   ├── AuctionEngine.ts - завершение раундов, распределение выигрышей
│   ├── BidService.ts    - размещение ставок, блокировка средств
│   ├── PaymentService.ts- депозит, вывод, списание
│   └── AuthService.ts   - регистрация и вход
├── routes/              - REST эндпоинты
└── scripts/             - bot_swarm, simulate_auction
```

### Frontend

```txt
frontend/src/
├── App.tsx       - состояние приложения, вкладки
├── api.ts        - HTTP клиент
└── main.tsx      - точка входа
```

---

## Выбор технологий

### Fastify вместо Express

Fastify в 2-3 раза быстрее Express за счёт схема-ориентированной сериализации. Встроенная валидация через JSON Schema. TypeScript из коробки.

Express медленнее и требует дополнительных пакетов для валидации. NestJS избыточен для проекта такого масштаба.

### MongoDB с Replica Set

Аукционы имеют вложенные структуры (раунды, items) - документная модель подходит лучше реляционной. Replica Set необходим для транзакций.

Без транзакций возможна ситуация: средства списаны, но ставка не создана (сбой между операциями). С транзакциями - атомарность: либо обе операции выполнены, либо ни одна. В этом демо размещение ставки (`BidService.placeBid`) выполняется в одной Mongo-транзакции вместе с блокировкой средств.

Optimistic Concurrency Control через поле `__v` в Mongoose предотвращает race conditions при одновременных ставках.

PostgreSQL подошёл бы, но потребовал бы больше кода для работы с вложенными структурами.

### Polling вместо WebSocket

Для демо-версии выбран polling (вместо WebSocket), чтобы упростить инфраструктуру и деплой. В интерфейсе polling **оптимизирован**: обновляются только данные текущего экрана (активные аукционы/детали аукциона/инвентарь/история), чтобы не создавать лишнюю нагрузку. В production может быть заменён на WebSocket/Socket.IO без изменения доменной модели.

---

## Ключевые инженерные решения

### 1) Атомарная ставка (деньги + ставка)

Критичный инвариант: **нельзя допустить** ситуацию «деньги заблокированы, но ставка не записалась» (или наоборот).

Поэтому в `BidService.placeBid()`:

- блокировка средств (`PaymentService.lockFunds`)
- создание/обновление ставки (`Bid.create` / `existingBid.save`)
- анти-снайпинг (возможное продление раунда)

выполняются в **одной MongoDB транзакции**.

### 2) Завершение раунда только по ставкам текущего раунда

В `AuctionEngine.resolveRound()` ставки фильтруются по `roundIndex`, чтобы результаты раунда не «засорялись» ставками из прошлых раундов.

### 3) Автоперенос проигравших ставок

Проигравшие активные ставки автоматически переносятся в следующий раунд (без новых запросов от клиента), средства остаются заблокированными до победы или завершения аукциона.

### 4) История транзакций как источник правды

Все финансовые операции пишутся в `Transactions` - это позволяет проверять целостность и отлаживать конкурентные сценарии.

### 5) Простая авторизация для демо

Для фокуса на backend-логике используется заголовок `x-user-id`. Это осознанный компромисс демо-версии; в production заменяется на JWT/Telegram auth.

---

## Запуск

### Требования

Docker и Docker Compose. Или: Node.js 22+, MongoDB 6.0+ с Replica Set.

### Стек

**Backend:**

- Node.js 22
- Fastify 4.26
- Mongoose 9.1
- TypeScript 5.9

**Frontend:**

- React 19.2
- Vite 7.2
- TypeScript 5.9

**Инфраструктура:**

- MongoDB 6.0 (Replica Set)
- Docker + Docker Compose

### Быстрый запуск (Docker Compose)

```bash
git clone https://github.com/y114git/TG_GIFTSAUCTION.git
cd TG_GIFTSAUCTION
docker-compose up --build
```

Frontend: <http://localhost:5173>  
Backend: <http://localhost:3000>  
MongoDB: localhost:27017

### Локальный запуск

Запуск MongoDB:

```bash
docker run -d --name mongo-rs -p 27017:27017 mongo:6.0 --replSet rs0
docker exec -it mongo-rs mongosh --eval "rs.initiate()"
```

Backend:

```bash
cd backend
npm install
npm run dev
```

Frontend:

```bash
cd frontend
npm install
npm run dev
```

### Переменные окружения

| Переменная | Значение по умолчанию | Назначение |
| ------------ | ---------------------- | ------------ |
| MONGO_URI | mongodb://localhost:27017/auction_db | URI MongoDB (Можно URL вместо URI) |
| PORT | 3000 | Порт backend |
| VITE_API_URL | <http://localhost:3000> | URL backend для frontend |

---

## Инфраструктура и деплой

### Почему MongoDB Replica Set

Проект использует MongoDB транзакции для атомарной ставки, поэтому в окружении необходим **Replica Set** (локально это поднимается через `docker-compose.yml`).

### Docker Compose

Mongo Replica Set требует специфичной инициализации. Docker Compose гарантирует воспроизводимость окружения и правильный порядок запуска сервисов.

### Railway (демо-деплой)

Демо развёрнуто на Railway (ссылка в разделе [Демо](#демо)). Для стабильной работы в облаке важно:

- использовать MongoDB с поддержкой транзакций (Replica Set / Atlas)
- держать `AuctionEngine` запущенным вместе с backend (это фоновый процесс завершения раундов)

## API

### Авторизация

```txt
POST /auth/login
{ "username": "player123" }

Ответ: { "_id": "...", "username": "player123", "balance": 0 }
```

### Аукционы

```txt
GET /auctions                  - список активных
GET /auctions/:id              - детали аукциона + topBids

POST /admin/auctions
x-user-id: <userId>
{
  "title": "Premium Gift",
  "roundsCount": 1,
  "duration": 60000,
  "winnersCount": 1,
  "minBid": 10
}
```

### Ставки

```txt
POST /auctions/:id/bid
x-user-id: <userId>
{ "amount": 100 }
```

### Платежи

```txt
POST /me/deposit
x-user-id: <userId>
{ "amount": 1000 }

POST /me/deposit
x-user-id: <userId>
{ "amount": -500 }
```

### Транзакции

```txt
GET /me/transactions
x-user-id: <userId>
```

### Передача подарка

```txt
POST /me/gift/transfer
x-user-id: <userId>
{ "bidId": "...", "recipientUsername": "player456" }

Ответ: { "success": true, "message": "Gift transferred to player456" }
```

### Мои ставки

```txt
GET /me/bids
x-user-id: <userId>

Ответ: { "auctionId1": 100, "auctionId2": 250 }
```

---

## Тестирование

### RPS Load Testing Tool

Агрессивный нагрузочный тест для определения максимального RPS (Requests Per Second), который может выдержать сервер:

```bash
cd backend
npm run bot-swarm 200
```

**Параметры:**
- Первый аргумент: количество ботов (по умолчанию 50)
- Второй аргумент: уровень concurrency (по умолчанию = количество ботов)

```bash
# 100 ботов, concurrency = 100
npm run bot-swarm 100

# 200 ботов, concurrency = 50
npm run bot-swarm 200 50
```

**Метрики в реальном времени:**
- **Current RPS** - текущий RPS (обновляется каждую секунду)
- **Max RPS** - максимальный достигнутый RPS
- **Average RPS** - средний RPS за весь тест
- **Success Rate** - процент успешных запросов
- **Avg Response Time** - среднее время ответа в миллисекундах
- **Top Errors** - топ-3 ошибок с количеством

Скрипт работает в агрессивном режиме без задержек между запросами, показывая реальную производительность сервера с учётом MongoDB транзакций, блокировок и всей бизнес-логики аукционов.

Для остановки теста нажмите `Ctrl+C` - будут показаны финальные результаты.

### Симуляция аукциона

Headless-тест без UI:

```bash
cd backend
npx ts-node --transpile-only src/scripts/simulate_auction.ts
```

Проверяет:

- Финансовый баланс: сумма депозитов равна сумме балансов + заблокировано + списано
- Отсутствие двойных списаний при конкурентных запросах
- Запись всех операций в журнал транзакций

---

## Структура репозитория

```txt
TG_GIFTSAUCTION/
├── backend/
│   ├── src/
│   │   ├── models/
│   │   ├── services/
│   │   ├── routes/
│   │   └── scripts/
│   ├── Dockerfile
│   └── package.json
├── frontend/
│   ├── src/
│   ├── Dockerfile
│   └── package.json
├── docker-compose.yml
└── README.md
```

---

Автор: [Y114]
